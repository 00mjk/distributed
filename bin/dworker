#!/usr/bin/env python

import logging
from sys import argv, exit
import socket

import click
from distributed import Nanny, Worker, sync
from distributed.utils import get_ip
from tornado.ioloop import IOLoop
from tornado import gen

logger = logging.getLogger('distributed.dworker')


@click.command()
@click.argument('center', type=str)
@click.option('--port', type=int, default=0, help="Serving port")
@click.option('--host', type=str, default=None, help="Serving host")
@click.option('--ncores', type=int, default=0, help="Number of cores to serve")
@click.option('--nprocesses', type=int, default=1, help="Number of worker processes")
def go(center, host, port, ncores, nprocesses):
    try:
        center_ip, center_port = center.split(':')
        center_port = int(center_port)
    except IndexError:
        logger.info("Usage:  dworker center_host:center_port")

    loop = IOLoop.current()
    nannies = [Nanny(center_ip, center_port, ncores=ncores, ip=host)
                for i in range(nprocesses)]

    for nanny in nannies:
        loop.add_callback(nanny._start, port)
    try:
        loop.start()
    except KeyboardInterrupt:
        @gen.coroutine
        def stop():
            results = yield [nanny._kill() for nanny in nannies]
            raise gen.Return(results)

        results = IOLoop().run_sync(stop)

        for r, nanny in zip(results, nannies):
            if r == b'OK':
                logger.info("End nanny at %s:%d", nanny.ip, nanny.port)
            else:
                logger.info("Failed to cleanly kill worker %s:%d",
                            nanny.ip, nanny.port)

if __name__ == '__main__':
    go()
